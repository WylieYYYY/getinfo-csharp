#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace WylieYYYY.GetinfoCSharp
{
	/// <summary>General non-domain-specific utilities.</summary>
	public static class Utility
	{
		#pragma warning disable CS1998
		/// <summary>Gets an empty asynchronous enumerator of a given value type.</summary>
		/// <returns>Empty asynchronous enumerator.</returns>
		public static async IAsyncEnumerator<TValue> EmptyAsyncEnumerator<TValue>() { yield break; }
		#pragma warning restore CS1998
		/// <summary>
		///  Retry executing <paramref name="func"/> by <paramref name="maxAttempts"/> times.
		///  Ends by either <paramref name="maxAttempts"/> times of attempt are done and exception
		///  still occurs, <paramref name="func"/> returns without exception,
		///  or <paramref name="beforeRetry"/> or <paramref name="exceptionFilter"/> throws.
		/// </summary>
		/// <param name="func">Function to be retried and get value from.</param>
		/// <param name="maxAttempts">Maximum amount to attempts, default is 0 for unlimited.</param>
		/// <param name="beforeRetry">
		///  Asynchronous function to be executed before each retry,
		///  default is null for not doing anything. This function's exceptions are unchecked.
		/// </param>
		/// <param name="exceptionFilter">
		///  Additional filter for selecting exception,
		///  default is null for no additional checks beyond type.
		/// </param>
		/// <returns>Asynchronous value returned by <paramref name="func"/>.</returns>
		public static async Task<TValue> AttemptRetry<TValue, TException>(Func<Task<TValue>> func,
				int maxAttempts = 0, Func<Task>? beforeRetry = null,
				Func<TException, bool>? exceptionFilter = null) where TException : Exception
		{
			for (int attemptCount = 1; true; attemptCount++)
			{
				try { return await func(); }
				catch (TException ex) when (exceptionFilter?.Invoke(ex) ?? true)
				{
					if (attemptCount == maxAttempts) throw;
					else await (beforeRetry?.Invoke() ?? Task.CompletedTask);
				}
			}
		}
		/// <summary>
		///  Completes tasks generated by <paramref name="taskGenerator"/>
		///  in chunks of size specified by <paramref name="chunkSize"/>.
		/// </summary>
		/// <param name="values">
		///  Asynchronous enumerator of values to use <paramref name="taskGenerator"/> on.
		/// </param>
		/// <param name="taskGenerator">Function to map each value to a task.</param>
		/// <param name="chunkSize">Size of each chunk.</param>
		/// <returns>Asynchronous enumerator of completed tasks' results.</returns>
		/// <exception cref="ArgumentOutOfRangeException">
		///  If <paramref name="chunkSize"/> is less than one.
		/// </exception>
		public static async IAsyncEnumerator<TOutput> ChunkComplete<TInput, TOutput>(
				this IAsyncEnumerator<TInput> values, Func<TInput, Task<TOutput>> taskGenerator,
				int chunkSize)
		{
			if (chunkSize <= 0) throw new ArgumentOutOfRangeException(nameof(chunkSize)/*HACK*/);
			List<Task<TOutput>> taskAccumulator = new(chunkSize);
			while (await values.MoveNextAsync())
			{
				do taskAccumulator.Add(taskGenerator(values.Current));
				while (taskAccumulator.Count != chunkSize && await values.MoveNextAsync());
				while (taskAccumulator.Any())
				{
					Task<TOutput> completedTask = await Task.WhenAny(taskAccumulator);
					taskAccumulator.Remove(completedTask);
					yield return await completedTask;
				}
			}
		}
		// TODO: remove this function when all enumerators are asynchronous
		[Obsolete("Remove this function when all enumerators are asynchronous.")]
		public static async IAsyncEnumerator<TValue> ToAsyncEnumerator<TValue>(
				this IEnumerator<TValue> enumerator)
		{
			while (enumerator.MoveNext()) yield return await ValueTask.FromResult(enumerator.Current);
		}
	}
}
