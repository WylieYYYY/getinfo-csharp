using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;
using System.Xml.Linq;

namespace getinfo_csharp
{
	class Program
	 {
		static async Task Main(string[] args)
		{
			Console.WriteLine("All data generated by this script is contained in scripts/unitinfo.js");
			Console.Write("Enter URL of target XML (Leave empty if using the same URL as previous run): ");
			string serviceUrl = Console.ReadLine();
			string executablePath = Path.GetDirectoryName(System.Reflection.Assembly.GetEntryAssembly().Location);
			Dictionary<string, string> overrideTable = GetOverrideTable(ref serviceUrl, executablePath);
			Console.WriteLine("XML request sent");
			XDocument serviceRoot = await RequestServiceXml(serviceUrl);
			XNamespace xmlnsUrl = Regex.Match(serviceRoot.Document.Root.Name.ToString(),
				@"(?<={)(https?://[^}]*)(?=})").Value;
			Console.WriteLine("Parsing address");
			Tuple<int[], string[], Tuple<int, int>> resultList = ParseAddress(serviceRoot, xmlnsUrl,
				overrideTable, executablePath);
			Console.WriteLine("Requesting for geospatial information");
			await BatchReq(resultList.Item1, resultList.Item2, serviceRoot,
				xmlnsUrl, resultList.Item3, overrideTable, executablePath);
			Console.WriteLine("Succesfully execute getinfo");
			Console.ReadLine();
		}
		
		private static readonly HttpClient client = new HttpClient();

		// handle request to the XML service, parse and dump
		private static async Task<XDocument> RequestServiceXml(string xmlUrl)
		{
			try
			{
				string response = await client.GetStringAsync(xmlUrl);
				return XDocument.Parse(response);
			}
			catch (HttpRequestException)
			{
				Console.WriteLine($"XML request for \"{xmlUrl}\" HTTP error");
				Console.ReadLine();
				Environment.Exit(1);
				throw new HttpRequestException();
			}
		}

		// create or read address override table
		private static Dictionary<string, string> GetOverrideTable(ref string xmlUrl,
			string executablePath)
		{
			Dictionary<string, string> table = new Dictionary<string, string>();
			if (File.Exists(executablePath + "/../override.csv"))
			{
				Console.WriteLine("Reading address override table");
				StreamReader stream = new StreamReader(executablePath + "/../override.csv", Encoding.UTF8);
				while (!stream.EndOfStream)
				{
					string[] fields = stream.ReadLine().Split('\t');
					if (fields[0] == "xml_url" && xmlUrl == "") xmlUrl = fields[1].TrimEnd();
					// ignore any entry key with lowercase character and empty line
					if (fields[0].Any(char.IsLower) || fields[0] == "") continue;
					table.Add(fields[0], string.Join('\t', fields.Skip(1).Select(s => s.Trim())));
				}
				stream.ReadLine();
				stream.Close();
			}
			else
			{
				Console.WriteLine("Creating address override table");
				// UTF8 BOM for Excel
				StreamWriter stream = new StreamWriter(executablePath + "/../override.csv", false, Encoding.UTF8);
				stream.WriteLine("See README for usage");
				stream.WriteLine("[Traditional Chinese Name]\t[Proposed Address]" +
					"\t[Longtitude Offset]\t[Latitude Offset]\t[Registered Address]");
				stream.Write("xml_url\t" + xmlUrl);
				stream.Close();
			}
			return table;
		}

		// take in XML root with specific tags and parse address
		private static Tuple<int[], string[], Tuple<int, int>> ParseAddress(XDocument root, XNamespace xmlnsUrl,
			Dictionary<string, string> overrideTable, string executablePath)
		{
			List<int> parsedIndex = new List<int>();
			List<string> parsedAddress = new List<string>();
			int unparsedCount = 0;
			StreamWriter overrideStream = new StreamWriter(executablePath + "/../override.csv", true, Encoding.UTF8);
			int unitIndex = 0;
			foreach (XElement unit in root.Descendants(xmlnsUrl + "serviceUnit"))
			{
				string location = unit.Descendants(xmlnsUrl + "addressEnglish").First().Value.ToUpper();
				// replace plate number list and stray double quote
				location = Regex.Replace(location, @"([0-9]+[A-Z]{0,2}, )(?=[0-9]+[A-Z]{0,2})", "");
				location = location.Replace("\"", "");
				// remove LOT and DD, use ALSO KNOWN AS tag to avoid
				location = Regex.Replace(location, @"LOTS? .* IN D\.?D\.? ?[0-9]+", "");
				location = Regex.Replace(location, @"D\.?D\.? [0-9]+ LOT [0-9]+", "");
				Match alternative = Regex.Match(location, @"(\(ALSO KNOWN AS )([^\)]*)(\)$)");
				if (alternative.Success) location = alternative.Groups[2].Value;
				// remove bracket from address and split into fields
				string bracketRegex = @"(\uFF08|\().*(\uFF09|\))";
				location = Regex.Replace(location, bracketRegex, "");
				string[] fields = location.Split(',');
				// strip trailig or leading space by comma
				fields = fields.Select(s => s.Trim()).ToArray();
				// reset flags detail decides if the scope is large enough
				bool detail = true;
				// when to start keeping for correct scope
				int trimIndex = 0;
				// the scope maybe large enough, but keep searching
				bool weakLarge = false;
				for (int index = 0; index < fields.Length; index++)
				{
					// remove additional number
					string stripNumRegex = @"([A-Z]{0,2}[0-9]+[A-Z]{0,2}(/F)? ?AND ?)" +
						@"(?=[A-Z]{0,2}[0-9]+[A-Z]{0,2}(/F)?)";
					foreach (string symbol in new string[]{ "AND", "=", "&" })
					{
						fields[index] = Regex.Replace(fields[index], stripNumRegex.Replace("AND", symbol), "");
					}
					// large enough scope, accept all
					if (!detail) continue;
					// do not attempt to parse address with lot number
					if (Regex.Match(fields[index], @"(( |^)LOT ?[0-9]+|( |^)D\.?D\.? ?[0-9]+)").Success) break;
					// remove all floor number but keep house info
					while (Regex.Match(fields[index], @"(G|[0-9])\/F").Success)
					{
						string floorRegex = @"(.*(G|[0-9])\/F (OF ?)?)(?=\S+)";
						bool regexMatched = Regex.Match(fields[index], floorRegex).Success;
						fields[index] = Regex.Replace(fields[index], floorRegex, "").Trim();
						if (regexMatched)
						{
							trimIndex = index;
							// the info following may not be useful
							weakLarge = true;
						}
						else
						{
							trimIndex = index + 1;
							break;
						}
					}
					// house number and street regex
					string numRegex = @"^(.* )?(NOS?\.? ?)?[0-9]+[A-Z]{0,2}";
					string ruralRoad = @"|KAM TIN SHI|SHEUNG LING PEI|SHEUNG WO CHE";
					string roadRegex = @".*(AVENUE|CIRCUIT|COURT|CRESCENT|DRIVE|LANE|LAU" +
						@"|PATH|ROAD|RD|STREET|TERRACE|TSUEN|VILLA(GE)?" + ruralRoad + @")";
					stripNumRegex = @"^.*[^0-9]+(?=[0-9]+)";
					// house number is put alongside street name
					if (Regex.Match(fields[index], numRegex + roadRegex).Success)
					{
						fields[index] = Regex.Replace(fields[index], stripNumRegex, "");
						trimIndex = index;
						detail = false;
						continue;
					}
					// house number in the field before street name
					if (Regex.Match(fields[index], numRegex + '$').Success &&
						fields.Length != index + 1 && Regex.Match(fields[index + 1], roadRegex).Success)
					{
						fields[index] = Regex.Replace(fields[index], stripNumRegex, "");
						// it will be picked up in the next loop
						fields[index + 1] = fields[index] + ' ' + fields[index + 1];
					}
					// check building name
					string ruralUnit = @"|PAK SHE";
					if (Regex.Match(fields[index], @"(BLOCK|BUILDING|CENT(ER|RE)|CHUEN|COURT" +
						@"|DAI HA|ESTATE|HOUSE|MALL|MANSION|TSUEN" + ruralUnit + @")$").Success)
					{
						// strip unclean floor name
						fields[index] = Regex.Replace(fields[index], @".* OF ", "");
						// strip flat number
						fields[index] = Regex.Replace(fields[index], @"[^0-9]*[0-9]+ ", "");
						trimIndex = index;
						detail = false;
						continue;
					}
					// strip unclean unit name
					fields[index] = Regex.Replace(fields[index], @"(.* AT )(?=.*)", "");
				}
				// scope not large enough, address is unparsed
				if (detail && !weakLarge)
				{
					string name = unit.Descendants(xmlnsUrl + "nameTChinese").First().Value.ToUpper();
					string address = unit.Descendants(xmlnsUrl + "addressTChinese").First().Value;
					if (!overrideTable.ContainsKey(name))
					{
						overrideStream.Write($"\n{name}\t[NO OVERRIDE]\t0\t0\t{address}");
					}
					unparsedCount++;
					Console.WriteLine("Unable to parse " + unit.Descendants(xmlnsUrl +
						"addressEnglish").First().Value);
				}
				else
				{
					parsedIndex.Add(unitIndex);
					// trim detail and join the address
					string address = string.Join(", ", fields.Skip(trimIndex));
					address = Regex.Replace(address, @", ?,", ",");
					parsedAddress.Add(address);
					Console.WriteLine("Parsed " + address);
				}
				unitIndex++;
			}
			overrideStream.Close();
			Console.WriteLine($"Parsing ratio is {parsedAddress.Count}:{unparsedCount}");
			// return all required data for traversing XML
			return new Tuple<int[], string[], Tuple<int, int>>(parsedIndex.ToArray(), parsedAddress.ToArray(),
				new Tuple<int, int>(parsedAddress.Count, unparsedCount));
		}

		// for finishing time estimation
		private static Pacer estimatePacer;
		private static readonly Random random = new Random();
		// process longitude and latitude from XML response
		private static async Task<(string, string, XDocument, float, float)> LonglatProcess(string requestUrl)
		{
			string address = HttpUtility.UrlDecode(requestUrl.Split("&q=")[1].Split("&i=")[0]);
			string response;
			try
			{
				response = await client.GetStringAsync(requestUrl);
			}
			// recovery prompt
			catch (HttpRequestException)
			{
				Console.WriteLine("Request failed for " + address + ", trying again");
				try
				{
					response = await client.GetStringAsync(requestUrl);
				}
				catch (HttpRequestException)
				{
					Console.WriteLine("Giving up, try diagnose network and rerun later");
					Console.ReadLine();
					Environment.Exit(1);
					throw new HttpRequestException();
				}
			}
			Console.WriteLine("Got response for " + address);
			Console.WriteLine("[Estimated time left: " + estimatePacer.Step().ToString() + ']');
			// traverse into the tree
			XDocument longlatRoot = XDocument.Parse(response);
			float lon = float.Parse(longlatRoot.Descendants("Longitude").First().Value);
			float lat = float.Parse(longlatRoot.Descendants("Latitude").First().Value);
			// distort slightly to reduce the chance of overlap
			lon += random.Next(-50, 50) / 1000000;
			lat += random.Next(-50, 50) / 1000000;
			return (requestUrl, address, longlatRoot, lon, lat);
		}

		// take in valid address list and perform API request
		private static async Task BatchReq(int[] parsedIndex, string[] parsedAddress, XDocument root,
			XNamespace xmlnsUrl, Tuple<int, int> ratio, Dictionary<string, string> overrideTable, string executablePath)
		{
			string lookupUrl = "https://www.als.ogcio.gov.hk/lookup?n=1&q=";
			// allocate full length longlat list
			XElement[] unitList = root.Descendants(xmlnsUrl + "serviceUnit").ToArray();
			Tuple<float, float>[] longlatList = new Tuple<float, float>[unitList.Length]
				.Select(t => new Tuple<float, float>(0, -91)).ToArray();
			// encode and request multiple URL simultaneously
			IEnumerable<string> requestGen = parsedAddress.Select((s, i) =>
				lookupUrl + HttpUtility.UrlEncode(s) + "&i=" + parsedIndex[i]);
			StreamWriter overrideStream = new StreamWriter(executablePath + "/../override.csv", true, Encoding.UTF8);
			estimatePacer = new Pacer(parsedIndex.Length);
			Task<(string, string, XDocument, float, float)>[] taskResponse;
			for (int batchStart = 0; batchStart < parsedIndex.Length; batchStart += 50)
			{
				taskResponse = requestGen.Skip(batchStart).Take(50).Select(s => LonglatProcess(s)).ToArray();
				await Task.WhenAll(taskResponse);
				foreach ((string requestUrl, string address, XDocument longlatRoot,
					float lon, float lat) in taskResponse.Select(t => t.Result))
				{
					// check district correctness
					int unitIndex = int.Parse(requestUrl.Split("&i=")[1]);
					XElement targetUnit = unitList[unitIndex];
					string parsedDistrict = targetUnit.Descendants(xmlnsUrl + "districtEnglish").First().Value;
					parsedDistrict = parsedDistrict.ToUpper().Replace(" AND ", " & ");
					string longlatDistrict = longlatRoot.Descendants("DcDistrict").First().Value;
					string name = targetUnit.Descendants(xmlnsUrl + "nameTChinese").First().Value.ToUpper();
					// append to override table if district test failed and no entry exists
					if (!longlatDistrict.Contains(parsedDistrict) && !overrideTable.ContainsKey(name))
					{
						Console.WriteLine("District test failed for " + address);
						string tcaddress = targetUnit.Descendants(xmlnsUrl + "addressTChinese").First().Value;
						overrideStream.Write($"\n{name}\t[NO OVERRIDE]\t0\t0\t{tcaddress}");
						ratio = new Tuple<int, int>(ratio.Item1 - 1, ratio.Item2 + 1);
						continue;
					}
					longlatList[unitIndex] = new Tuple<float, float>(lon, lat);
				}
			}
			Console.WriteLine($"Query ratio is {ratio.Item1}:{ratio.Item2}");
			overrideStream.Close();
			Console.WriteLine("Requesting override table");
			requestGen = overrideTable.Where(
				kv => kv.Value.Split('\t')[0] != "[NO OVERRIDE]")
				.Select(kv => lookupUrl + HttpUtility.UrlEncode(
				overrideTable[kv.Key].Split('\t')[0]) + "&i=" + HttpUtility.UrlEncode(kv.Key));
			Dictionary<string, Tuple<float, float>> longlatOverrideTable =
				new Dictionary<string, Tuple<float, float>>();
			estimatePacer.Restart(requestGen.Count());
			for (int batchStart = 0; batchStart < requestGen.Count(); batchStart += 50)
			{
				taskResponse = requestGen.Skip(batchStart).Take(50).Select(s => LonglatProcess(s)).ToArray();
				await Task.WhenAll(taskResponse);
				foreach ((string requestUrl, _, _, float lon, float lat) in taskResponse.Select(t => t.Result))
				{
					string nameKey = HttpUtility.UrlDecode(requestUrl.Split("&i=")[1]);
					string[] offset = overrideTable[nameKey].Split('\t').Skip(1).Take(2).ToArray();
					longlatOverrideTable.Add(nameKey + "\tLongLat", new Tuple<float, float>(
						lon + float.Parse(offset[0]), lat + float.Parse(offset[1])));
				}
			}
			estimatePacer.Stop();
			Console.WriteLine("Applying override table");
			List<Dictionary<string, string>> unitDictList = new List<Dictionary<string, string>>();
			foreach (XElement unit in root.Descendants(xmlnsUrl + "serviceUnit"))
			{
				Dictionary<string, string> propDict = new Dictionary<string, string>();
				foreach (XElement prop in unit.Descendants())
				{
					propDict.Add(prop.Name.LocalName, prop.Value);
				}
				unitDictList.Add(propDict);
			}
			for (int index = 0; index < unitDictList.Count; index++)
			{
				// define None for default address override
				unitDictList[index].Add("addressOverride", "");
				string nameKey = unitDictList[index]["nameTChinese"].ToUpper();
				if (longlatOverrideTable.ContainsKey(nameKey + "\tLongLat"))
				{
					longlatList[index] = longlatOverrideTable[nameKey + "\tLongLat"];
					unitDictList[index]["addressOverride"] = overrideTable[nameKey].Split('\t')[0];
				}
			}
			Console.WriteLine("Reordering data by decreasing latitude");
			IEnumerable<(int, Tuple<float, float>)> zip = Enumerable.Range(0, longlatList.Length).Zip(longlatList);
			zip = zip.OrderByDescending(kv => kv.Item2.Item2);
			int[] latUnitMap = zip.Select(kv => kv.Item1).ToArray();
			longlatList = zip.Select(kv => kv.Item2).ToArray();
			// uses JS to avoid CORS
			Console.WriteLine("Writing langlat and dumping XML as JS to unitinfo.js");
			using (StreamWriter stream = new StreamWriter(executablePath +
				"/../scripts/unitinfo.js", false, Encoding.UTF8))
			{
				stream.Write("var longlat = [");
				bool firstWrite = true;
				foreach (Tuple<float, float> longlat in longlatList)
				{
					if (!firstWrite) stream.Write(',');
					stream.Write($"[{longlat.Item1},{longlat.Item2}]");
					firstWrite = false;
				}
				stream.Write("];\nvar unitinfo = [[");
				stream.Write(string.Join(',', unitDictList[0].Keys.Select(k => $"\"{k}\"")));
				stream.Write(']');
				foreach (int latIndex in latUnitMap)
				{
					stream.Write(",[");
					stream.Write(string.Join(',', unitDictList[latIndex]
						.Values.Select(v => v == ""? "null" : $"\"{v}\"")));
					stream.Write(']');
				}
				stream.Write("];");
			}
			Console.WriteLine("Finished unitinfo.js");
		}
	}
}
